
TASK 1(FRONT END LAZYSIZE);

lazy size is  just used to load the images only when the user vies it it maks the 
insitail loading of website very easy also it makes the image responsive on its own it can be used parally wirh js or react or any frmaework
lets say  i have to diplay a image only upon hovering it normally it wd be loaded before the hover but will not be dilsplayed but using lazysize it will
lkoad the image only aftet if i hover through it and display it 
Picturefill is a complete solution for making images responsive in all browsers.
lazySizes with respimg is a lighter, more focused solution that only handles the essential parts of responsive images and relies on another tool (lazySizes) to work.

***
 The responsive image standard in 
 HTML allows you to provide different versions 
 of an image for different screen sizes and resolutions. This ensures that users download the best
  version of an image for their device, saving bandwidth and improving load times.
***
The lazySizes library is built on the responsive
 image standard, meaning it understands the basic principles of serving the right image for the right device. 
 The respimg extension extends this functionality, allowing lazySizes to manage responsive images, 
but in a more lightweight and focused manner.

`this is the diff between partially fill and picture fill

Full Support: The srcset attribute allows you to provide a list of image sources with different resolutions (e.g., 1x, 2x for Retina displays) or different widths, letting the browser choose the best one based on the device.
Partial Support: The respimg extension focuses on essential use cases, such as choosing the correct image based on resolution. However, it might not support all variations, such as complex width descriptors combined with the sizes attribute.
sizes Attribute:

Full Support: The sizes attribute works with srcset to tell the browser how wide the image will be in the layout, helping it choose the appropriate image from the srcset.
Partial Support: This attribute is sometimes omitted or simplified in partial polyfills like the respimg extension because it requires the browser to make complex calculations about layout. The extension might instead focus on simpler scenarios.


2. React.lazy and Suspense for components 
loading on demand or in parallel‚Äù is lazy-loading.
Opposite of lazy-loading is eager-loading. Here everything is loaded no matter if you use it or not.

https://www.freecodecamp.org/news/how-to-use-react-lazy-and-suspense-for-components-lazy-loading-8d420ecac58/

THIS SITE CLEARLY EXPLAINS ALL THE DIFFERNCE BETWEEN EAGER LOADING AND LAZY LOADING 


***
Even though we use PDFPreview only on user click, all code related to it is included in the app bundle:
![alt text](image.png)
This is a development environment. In production, the sizes would be significantly smaller. Still, we‚Äôre not splitting the code optimally.




suspense will by default will add a spinner emoji 

Suspense accepts a fallback component which allows you to display any React component as a loading state. The following example shows how this works. The avatar is only rendered when the button is clicked, where a request is then made to retrieve the code necessary for the suspended AvatarComponent. In the meantime, the fallback loading component is shown.
 <Suspense fallback={renderLoader()}>

 instead of this render loader u can use anyther componet u want 
    <AvatarComponent />
  </Suspense>


  return (
    <>
      <h1>{artist.name}</h1>
      <Suspense fallback={<Loading />}>
        <Albums artistId={artist.id} />
      </Suspense>
    </>
  );
}

function Loading() {
  return <h2>üåÄ Loading...</h2>;
}


faced this error while using dark mode 
https://stackoverflow.com/questions/72114775/vite-global-is-not-defined

solution::


yes, i am facing the same issue. As soon i use the hook, my app crashes with an error use-dark-mode.m.js:1 Uncaught ReferenceError: global is not defined. I am using vite with react 17

The error goes away if i put var global = globalThis; in my index.html file





in taliwnd classs just add a seperate for dark and inside the tailwindconfig.js add this 
darkMode: 'class',



now using redux 

here its basically a paakage which manages all  my states in a single file and im saving it in store.js file 

isnide this declare and use all your use states 

and in jsx file handle this way 










Redux is ideal for large-scale applications where predictability and explicit state changes are crucial. It shines in applications where state management complexity can grow over time.

MobX is a great choice for smaller to medium-sized applications where ease of use and performance are priorities. Its minimal boilerplate and reactive nature make it a strong contender for quickly scaling applications with simple state needs.

in a single line i can set many states like in a single pass or call i can chnage loading , add value , and anything ekse 

To use the store.js in your React application, you need to wrap your application with the Provider component from react-redux, which makes the Redux store available to all components in the app.

In your main.jsx or index.js file (wherever you render your React app), you need to wrap the app with the Provider and pass in the store.

import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import { Provider } from 'react-redux';
import store from './store'; // Make sure this path is correct

ReactDOM.createRoot(document.getElementById('root')).render(
  <Provider store={store}>
    <App />
  </Provider>
);


/// in my case i have impleted it only in the  book.jsx file